// Wymagane biblioteki

#include <OneWire.h>                                                                       
#include <Arduino.h>
#include <SPI.h>
#include <U8g2lib.h>
#include <Wire.h>

// Pin pomiarowy baterii

#define BATERIA 3

// Piny przycisków

#define PRAWO 7    // przycisk do poruszania menu w prawo
#define LEWO 6     // przycisk do poruszania menu w lewo
#define OK 8       // przycisk OK do egzekucji danej pozycji menu
#define ANULUJ 5   // przycisk powrotu do poprzedniej wartości menu lub wyjścia z dajego polecenia

// Konstruktor wyświetlacza

U8G2_SSD1306_128X64_NONAME_2_HW_I2C u8g2(U8G2_R0); // I2C device found at address 0x3C dla czarnego 0.96 cala oraz czerwonego 0.96 cala

// Stałe do pomiarów
const int Ro = 16000; //Ro zmienna rezystancji dla czystego powietrza gdy f(PomiarTemp) = 1
const int RL = 8900; //Rezystor podpiętu między masą a pinem 2 czujnika Figaro

// Zmienne do pomiarów
float RS;
float VRL;
float currentTemp;
float PomiarTemp;
float wynik;
float napieciePomiarowe;
float napiecieWynikowe;

int stanBaterii = 5;
byte bateriaDelay = 0;
int pomiarBaterii = 0;
int stanTemp = 0;

// Zmienne do wyświetlania

float minVal;
float maxVal;
float v;

float punkt;
byte xp;
byte yp;

// Rozmiary dla obrazków

#define meatCheckW 54
#define meatCheckH 44
#define logo60 60
#define ikona12 12
#define exW 70
#define exH 48
#define bateriaW 14
#define bateriaH 6
#define navIkonaW 9
#define navIkonaH 6
#define OPDProz 56

// Obrazki w formacie XBM
static const unsigned char  meatCheckLogo[] U8X8_PROGMEM =  {  
  0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 
  0x07, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 
  0x07, 0xC0, 0x3F, 0x00, 0x00, 0x80, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 
  0xE0, 0x1F, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0xF0, 
  0x01, 0x00, 0xF8, 0x01, 0x00, 0x00, 0xE0, 0x03, 0x00, 0xFC, 0x00, 0x00, 
  0x00, 0xC0, 0x07, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x80, 0x0F, 0x80, 0x1F, 
  0x00, 0x00, 0x00, 0x00, 0x0F, 0xC0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x1F, 
  0xE0, 0x07, 0x00, 0x00, 0x78, 0x00, 0x1E, 0xF0, 0x03, 0x00, 0x00, 0xFE, 
  0x01, 0x1C, 0xF8, 0x01, 0x00, 0x00, 0xFF, 0x03, 0x3C, 0xF8, 0x00, 0x00, 
  0x00, 0xFF, 0x07, 0x3C, 0x7C, 0x00, 0x00, 0x80, 0x8F, 0x07, 0x38, 0x3E, 
  0x00, 0x00, 0x80, 0x07, 0x07, 0x38, 0x1F, 0x00, 0x00, 0x80, 0x03, 0x07, 
  0x38, 0x0F, 0x00, 0x00, 0x80, 0x07, 0x07, 0x38, 0x0F, 0x00, 0x00, 0x80, 
  0x8F, 0x07, 0x38, 0x07, 0x00, 0x00, 0x00, 0xFF, 0x07, 0x38, 0x07, 0x00, 
  0x00, 0x00, 0xFF, 0x03, 0x38, 0x07, 0x00, 0x00, 0x00, 0xFE, 0x01, 0x38, 
  0x07, 0x00, 0x00, 0x00, 0x78, 0x00, 0x38, 0x07, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x38, 0x07, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x3C, 0x0F, 0xFF, 0x3F, 
  0x00, 0x00, 0x00, 0x3E, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x3F, 0xFF, 
  0xFF, 0xFF, 0x03, 0x00, 0x80, 0x3F, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xC0, 
  0x3F, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0xFC, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0x3F, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 
  0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFC, 0x1F, 0xFE, 0xFF, 0xFF, 
  0xFF, 0x0F, 0xF8, 0x01, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x80, 
  0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x01, 0x00, 
  0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x3F, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x0F, 0x00,  };

static const unsigned char  NOTlogo[] U8X8_PROGMEM ={
  0x00, 0x00, 0x80, 0x01, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x01, 
  0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x03, 0xFC, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 
  0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 
  0xFF, 0x1F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 
  0x00, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0x00, 0x80, 0xFF, 0xFF, 0x01, 
  0xF8, 0xFF, 0x1F, 0x00, 0xC0, 0xFF, 0x3F, 0x00, 0xC0, 0xFF, 0x3F, 0x00, 
  0xE0, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0x07, 0x00, 
  0x00, 0xFE, 0x7F, 0x00, 0xF0, 0xFF, 0x01, 0x00, 0x00, 0xF8, 0xFF, 0x00, 
  0xF8, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x01, 0xF8, 0x7F, 0x00, 0x00, 
  0x00, 0xE0, 0xFF, 0x01, 0xE0, 0x3F, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 
  0xE0, 0xBF, 0xC3, 0xE1, 0xF1, 0x9F, 0x7F, 0x00, 0xE0, 0x9F, 0xC3, 0xF9, 
  0xF7, 0x9F, 0x7F, 0x00, 0xE0, 0x8F, 0xC3, 0xF9, 0xF7, 0x1F, 0x7F, 0x00, 
  0xF0, 0x8F, 0xC7, 0x39, 0x87, 0x03, 0xFF, 0x00, 0xF0, 0x87, 0xC7, 0x1D, 
  0x8E, 0x03, 0xFE, 0x00, 0xF8, 0x87, 0xC7, 0x1D, 0x8E, 0x03, 0xFE, 0x01, 
  0xF8, 0x87, 0xCF, 0x1D, 0x8E, 0x03, 0xFE, 0x01, 0xFF, 0x87, 0xCF, 0x1D, 
  0x8E, 0x03, 0xFC, 0x0F, 0xFF, 0x83, 0xCF, 0x1D, 0x8E, 0x03, 0xFC, 0x0F, 
  0xFF, 0x83, 0xDF, 0x1D, 0x8E, 0x03, 0xFC, 0x0F, 0xFF, 0x83, 0xDF, 0x1D, 
  0x8E, 0x03, 0xFC, 0x0F, 0xFF, 0x83, 0xDF, 0x1D, 0x8E, 0x03, 0xFC, 0x0F, 
  0xFF, 0x83, 0xDB, 0x1D, 0x8E, 0x03, 0xFC, 0x0F, 0xFF, 0x83, 0xFB, 0x1D, 
  0x8E, 0x03, 0xFC, 0x0F, 0xFF, 0x83, 0xFB, 0x1D, 0x8E, 0x03, 0xFC, 0x0F, 
  0xFF, 0x83, 0xF3, 0x1D, 0x8E, 0x03, 0xFC, 0x0F, 0xFF, 0x87, 0xF3, 0x1D, 
  0x8E, 0x03, 0xFC, 0x0F, 0xF8, 0x87, 0xF3, 0x1D, 0x8E, 0x03, 0xFE, 0x01, 
  0xF8, 0x87, 0xE3, 0x1D, 0x8E, 0x03, 0xFE, 0x01, 0xF0, 0x87, 0xE3, 0x1D, 
  0x8E, 0x03, 0xFE, 0x00, 0xF0, 0x8F, 0xE3, 0x39, 0x87, 0x03, 0xFF, 0x00, 
  0xE0, 0x8F, 0xC3, 0xF9, 0x87, 0x03, 0x7F, 0x00, 0xE0, 0x9F, 0xC3, 0xF9, 
  0x87, 0x83, 0x7F, 0x00, 0xE0, 0x3F, 0x00, 0xE0, 0x01, 0x80, 0x7F, 0x00, 
  0xE0, 0x3F, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0xF8, 0x7F, 0x00, 0x00, 
  0x00, 0xE0, 0xFF, 0x01, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x01, 
  0xF0, 0xFF, 0x01, 0x00, 0x00, 0xF8, 0xFF, 0x00, 0xE0, 0xFF, 0x07, 0x00, 
  0x00, 0xFE, 0x7F, 0x00, 0xE0, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 
  0xC0, 0xFF, 0x3F, 0x00, 0xC0, 0xFF, 0x3F, 0x00, 0x80, 0xFF, 0xFF, 0x01, 
  0xF8, 0xFF, 0x1F, 0x00, 0x00, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0x00, 
  0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 
  0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 
  0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0x03, 0xFC, 0x07, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x01, 
  0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x18, 0x00, 0x00, 0x00,  };

static const unsigned char  exLogo[] U8X8_PROGMEM = {
  0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x3C, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x1F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 
  0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0xC0, 0x1F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0xE0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFC, 0x01, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x03, 
  0xF8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 0xF8, 0x03, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0xFC, 0x03, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF0, 0x0F, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 
  0xFC, 0x01, 0xC0, 0x3F, 0x00, 0xFF, 0x00, 0xE0, 0x0F, 0xFE, 0x01, 0xC0, 
  0x7F, 0x80, 0xFF, 0x00, 0xE0, 0x1F, 0xFE, 0x01, 0xC0, 0xFF, 0xC0, 0xFF, 
  0x00, 0xE0, 0x1F, 0xFE, 0x00, 0xC0, 0xFF, 0xE1, 0xFF, 0x00, 0xC0, 0x1F, 
  0xFE, 0x00, 0xC0, 0xFF, 0xF3, 0xFF, 0x00, 0xC0, 0x1F, 0xFE, 0x00, 0x00, 
  0xFC, 0xFF, 0x0F, 0x00, 0xC0, 0x1F, 0xFF, 0x00, 0x00, 0xF8, 0xFF, 0x07, 
  0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0xF0, 0xFF, 0x03, 0x00, 0xC0, 0x3F, 
  0xFF, 0x00, 0x00, 0xE0, 0xFF, 0x01, 0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 
  0xC0, 0xFF, 0x00, 0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0xC0, 0xFF, 0x00, 
  0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0xC0, 0x3F, 
  0xFF, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 
  0xC0, 0xFF, 0x00, 0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0xC0, 0xFF, 0x00, 
  0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0xE0, 0xFF, 0x01, 0x00, 0xC0, 0x3F, 
  0xFF, 0x00, 0x00, 0xF0, 0xFF, 0x03, 0x00, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 
  0xF8, 0xFF, 0x07, 0x00, 0xC0, 0x3F, 0xFE, 0x00, 0x00, 0xFC, 0xFF, 0x0F, 
  0x00, 0xC0, 0x1F, 0xFE, 0x00, 0xC0, 0xFF, 0xF3, 0xFF, 0x00, 0xC0, 0x1F, 
  0xFE, 0x00, 0xC0, 0xFF, 0xE1, 0xFF, 0x00, 0xC0, 0x1F, 0xFE, 0x01, 0xC0, 
  0xFF, 0xC0, 0xFF, 0x00, 0xE0, 0x1F, 0xFE, 0x01, 0xC0, 0x7F, 0x80, 0xFF, 
  0x00, 0xE0, 0x1F, 0xFC, 0x01, 0xC0, 0x3F, 0x00, 0xFF, 0x00, 0xE0, 0x0F, 
  0xFC, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 0xFC, 0x03, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xF8, 0x03, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF0, 0x07, 0xF8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 
  0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x03, 0xE0, 0x0F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFC, 0x01, 0xC0, 0x1F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFE, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 
  0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3E, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x0F, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
  };

static const unsigned char ElektronikLogo[] U8X8_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x80, 0xC7, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0xFE, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x01, 0xC0, 0x1F, 0x00, 0x00, 0x00, 
  0x00, 0xF0, 0x00, 0x00, 0xFE, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 
  0xF0, 0x1F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xFE, 0x01, 0x00, 
  0x00, 0x1E, 0x00, 0x00, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0xFF, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x06, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0x80, 0xF3, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x03, 
  0x80, 0xF3, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x03, 0x80, 0xF9, 0xFF, 0x1F, 
  0x00, 0x00, 0x00, 0x03, 0x80, 0x3D, 0xC0, 0xFF, 0x00, 0x00, 0x00, 0x03, 
  0x80, 0x1F, 0x00, 0xF8, 0x03, 0x00, 0x00, 0x03, 0xC0, 0x07, 0x00, 0x80, 
  0x1F, 0x00, 0x80, 0x03, 0xC0, 0x03, 0x00, 0x00, 0x3E, 0x00, 0x80, 0x01, 
  0xC0, 0x03, 0x00, 0x00, 0x70, 0x00, 0x80, 0x01, 0xC0, 0x01, 0x00, 0x00, 
  0xE0, 0x00, 0x80, 0x01, 0xC0, 0x01, 0xF8, 0x00, 0xC0, 0x01, 0x80, 0x01, 
  0xC0, 0x01, 0xFC, 0x1F, 0xC0, 0x01, 0x80, 0x01, 0xE0, 0x00, 0x1C, 0x7E, 
  0x80, 0x03, 0xC0, 0x01, 0xE0, 0x00, 0x3E, 0xF0, 0x80, 0x03, 0xC0, 0x00, 
  0xE0, 0x00, 0xFC, 0xF3, 0x00, 0x03, 0xC0, 0x00, 0xE0, 0x00, 0xC0, 0xFF, 
  0x00, 0x03, 0xC0, 0x00, 0xE0, 0x00, 0x00, 0xFC, 0x00, 0x03, 0xC0, 0x00, 
  0xE0, 0x00, 0x00, 0xE0, 0x00, 0x03, 0xC0, 0x00, 0x70, 0x00, 0x00, 0x00, 
  0x00, 0x03, 0xE0, 0x00, 0x70, 0x00, 0x0F, 0x00, 0x80, 0x03, 0xE0, 0x00, 
  0x70, 0x80, 0x3F, 0x00, 0x80, 0x03, 0x60, 0x00, 0x70, 0x80, 0xF3, 0x03, 
  0x80, 0x01, 0x60, 0x00, 0x70, 0x80, 0xC7, 0x0F, 0x80, 0x01, 0x60, 0x00, 
  0x70, 0x00, 0x0F, 0xFC, 0x81, 0x00, 0x60, 0x00, 0x78, 0x00, 0x3F, 0xF0, 
  0xFF, 0x00, 0x70, 0x00, 0xF8, 0x00, 0xFC, 0x39, 0xFE, 0x00, 0x70, 0x00, 
  0xD8, 0x01, 0xE0, 0x3F, 0x70, 0x00, 0x30, 0x00, 0xD8, 0x03, 0x00, 0x0F, 
  0x60, 0x00, 0x30, 0x00, 0x98, 0x07, 0x00, 0x00, 0x60, 0x00, 0x30, 0x00, 
  0x18, 0x1F, 0x00, 0x00, 0x60, 0x00, 0x30, 0x00, 0x0C, 0x7E, 0x00, 0x00, 
  0x60, 0x00, 0x30, 0x00, 0x0C, 0xF8, 0x00, 0x00, 0x60, 0x00, 0x38, 0x00, 
  0x0C, 0xF0, 0x07, 0x00, 0x30, 0x00, 0x3C, 0x00, 0xFC, 0xC0, 0x3F, 0x00, 
  0x18, 0x00, 0x1E, 0x00, 0xF8, 0x07, 0xFF, 0x00, 0x1E, 0x00, 0x0F, 0x00, 
  0x80, 0x3F, 0xFC, 0xFF, 0x0F, 0x80, 0x07, 0x00, 0x00, 0xFC, 0xC3, 0xFF, 
  0x03, 0xC0, 0x01, 0x00, 0x00, 0xC0, 0x1F, 0x00, 0x00, 0xF0, 0x00, 0x00, 
  0x00, 0x00, 0xFC, 0x01, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 
  0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xF8, 0x87, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 
  };


static const unsigned char OPDP[] U8X8_PROGMEM = {
  0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0x01, 0x7E, 0x80, 0x03, 0x00, 0x00, 0xF0, 0x03, 
  0x7E, 0xC0, 0x0F, 0x00, 0x00, 0xF8, 0x07, 0x7E, 0xE0, 0x1F, 0x00, 0x00, 
  0xFC, 0x07, 0xFF, 0xE0, 0x3F, 0x00, 0x00, 0xFC, 0xCF, 0xFF, 0xF3, 0x3F, 
  0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 
  0xFF, 0x0F, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xE0, 
  0xFF, 0xC1, 0xFF, 0x07, 0x00, 0x10, 0xE0, 0x7F, 0x00, 0xFE, 0x07, 0x08, 
  0x78, 0xF0, 0x0F, 0x00, 0xF0, 0x0F, 0x1E, 0xF8, 0xF9, 0x07, 0x00, 0xE0, 
  0x9F, 0x1F, 0xFC, 0xFF, 0x81, 0xFF, 0x81, 0xFF, 0x3F, 0xFC, 0xFF, 0xE0, 
  0x00, 0x07, 0xFF, 0x3F, 0xFE, 0x3F, 0x30, 0x00, 0x0C, 0xFC, 0x7F, 0xFE, 
  0x3F, 0x10, 0x7E, 0x08, 0xFC, 0x7F, 0xFC, 0x1F, 0x18, 0xFF, 0x18, 0xF8, 
  0x3F, 0xF0, 0x1F, 0x08, 0xC3, 0x11, 0xF8, 0x0F, 0xC0, 0x0F, 0x0C, 0x80, 
  0x31, 0xF0, 0x03, 0x80, 0x0F, 0x04, 0x80, 0x21, 0xF0, 0x01, 0x80, 0x0F, 
  0x04, 0xC0, 0x21, 0xF0, 0x01, 0x80, 0x07, 0x04, 0xE0, 0x20, 0xE0, 0x01, 
  0xC0, 0x07, 0x04, 0x70, 0x20, 0xE0, 0x03, 0xFF, 0x03, 0x0C, 0x38, 0x30, 
  0xE0, 0xFF, 0xFF, 0x03, 0x08, 0x18, 0x10, 0xE0, 0xFF, 0xFF, 0x03, 0x08, 
  0x18, 0x10, 0xE0, 0xFF, 0xFF, 0x03, 0x18, 0x00, 0x18, 0xE0, 0xFF, 0xFF, 
  0x03, 0x30, 0x00, 0x0C, 0xE0, 0xFF, 0xFF, 0x07, 0x60, 0x18, 0x06, 0xE0, 
  0xFF, 0xC0, 0x07, 0x40, 0x18, 0x02, 0xE0, 0x03, 0x80, 0x07, 0xC0, 0x00, 
  0x03, 0xE0, 0x01, 0x80, 0x0F, 0x80, 0xFF, 0x01, 0xF0, 0x01, 0x80, 0x0F, 
  0x80, 0x00, 0x01, 0xF0, 0x01, 0xC0, 0x0F, 0x80, 0x00, 0x01, 0xF0, 0x03, 
  0xF0, 0x1F, 0x80, 0xFF, 0x01, 0xF8, 0x0F, 0xFC, 0x1F, 0x80, 0x00, 0x01, 
  0xF8, 0x3F, 0xFE, 0x3F, 0x80, 0xFF, 0x01, 0xFC, 0x7F, 0xFE, 0x3F, 0x80, 
  0x81, 0x01, 0xFC, 0x7F, 0xFC, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x3F, 0xFC, 
  0xFF, 0x01, 0x42, 0x80, 0xFF, 0x3F, 0xF8, 0xF9, 0x07, 0x66, 0xE0, 0x9F, 
  0x1F, 0x78, 0xF0, 0x0F, 0x3C, 0xF0, 0x0F, 0x1E, 0x10, 0xE0, 0x7F, 0x00, 
  0xFE, 0x07, 0x08, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0xF0, 
  0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 
  0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFC, 0xCF, 0xFF, 0xF3, 
  0x3F, 0x00, 0x00, 0xFC, 0x07, 0xFF, 0xE0, 0x3F, 0x00, 0x00, 0xF8, 0x07, 
  0x7E, 0xE0, 0x1F, 0x00, 0x00, 0xF0, 0x03, 0x7E, 0xC0, 0x0F, 0x00, 0x00, 
  0xC0, 0x01, 0x7E, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, };

static const unsigned char bateria[] U8X8_PROGMEM = {
  0xFE, 0x3F, 0x03, 0x20, 0x03, 0x20, 0x03, 0x20, 0x03, 0x20, 0xFE, 0x3F, 
  };

static const unsigned char mieso[] U8X8_PROGMEM = {
  0x00, 0x00, 0xE0, 0x03, 0x18, 0x04, 0x04, 0x04, 0x82, 0x08, 0xC1, 0x09, 
  0x81, 0x08, 0x01, 0x08, 0x01, 0x08, 0x79, 0x0C, 0xFF, 0x0F, 0xCE, 0x07, 
  };

static const unsigned char mucha[] U8X8_PROGMEM = {
  0x00, 0x02, 0x38, 0x03, 0xC6, 0x0F, 0x81, 0x07, 0x81, 0x03, 0x43, 0x02, 
  0x3C, 0x04, 0x3E, 0x04, 0x3F, 0x04, 0x3F, 0x02, 0x5E, 0x02, 0xCC, 0x01, 
  };

static const unsigned char navOK[] U8X8_PROGMEM = {
  0x26, 0x01, 0xA9, 0x00, 0x69, 0x00, 0x69, 0x00, 0xA9, 0x00, 0x26, 0x01,
  };

static const unsigned char navPowrot[] U8X8_PROGMEM = {
  0x04, 0x00, 0x06, 0x00, 0xFF, 0x00, 0xFF, 0x01, 0x86, 0x01, 0xC4, 0x00, 
  };


// MENU
// Stałe w menu

const char menu0[] PROGMEM = "Menu główne";

const char menu2_1_1[] PROGMEM = "Szynka gotowana";
const char menu2_1_2[] PROGMEM = "Szynka konserwowa";
const char menu2_1_3[] PROGMEM = "Szynka wędzona";
const char menu2_1_4[] PROGMEM = "Mielonka tyrolska";

const char menu2_2_1[] PROGMEM = "Filet";
const char menu2_2_2[] PROGMEM = "Wątróbka";
const char menu2_2_3[] PROGMEM = "Udka, podudzia itp.";

const char menu2_3_1[] PROGMEM = "Karkówka";
const char menu2_3_2[] PROGMEM = "Polędwica";
const char menu2_3_3[] PROGMEM = "Podroby wołowe";
const char menu2_3_4[] PROGMEM = "Inne";

const char menu2_4_1[] PROGMEM = "Schab";
const char menu2_4_2[] PROGMEM = "Boczek";
const char menu2_4_3[] PROGMEM = "Szynka";
const char menu2_4_4[] PROGMEM = "Łopatka";
const char menu2_4_5[] PROGMEM = "Inne";

const char menu2_5_1[] PROGMEM = "Ryba słodka";
const char menu2_5_2[] PROGMEM = "Ryba słona";
const char menu2_5_3[] PROGMEM = "Ryba marynowana";


const char menu2_1[] PROGMEM = "Wędlina";
const char menu2_2[] PROGMEM = "Kurczak";
const char menu2_3[] PROGMEM = "Wołowina";
const char menu2_4[] PROGMEM = "Wieprzowina";
const char menu2_5[] PROGMEM = "Ryba";

const char menu1[] PROGMEM = "Pomiar na żywo";
const char menu2[] PROGMEM = "Wybór mięs";
const char menu3[] PROGMEM = "Wyłącz urządzenie";

// Lista pozycji menu ułożona zgodnie z indeksami

const char *const listaMenu[] PROGMEM = {
  menu1, menu2, menu3,
    menu2_1, menu2_2, menu2_3, menu2_4, menu2_5,
      menu2_1_1, menu2_1_2, menu2_1_3, menu2_1_4,
      menu2_2_1, menu2_2_2, menu2_2_3,
      menu2_3_1, menu2_3_2, menu2_3_3, menu2_3_4,
      menu2_4_1, menu2_4_2, menu2_4_3, menu2_4_4, menu2_4_5,
      menu2_5_1, menu2_5_2, menu2_5_3
};

// Lista każdego subemu drzewa

const char *const listaSubmenu[] PROGMEM = {
  menu0,
    menu2,
      menu2_1, menu2_2, menu2_3, menu2_4, menu2_5
};


// Dla szybszego wykonywania programu i uniknięcia błędów stałe rozmiarów menu są zapisane w pamięci SRAM

const int indeksy[20] = {
  0, 3, 8, 12, 15, 19, 24 
};

const int rozmiary[20] = {
  3, 5, 4, 3, 4, 5, 3
};


// Zmienna uniemożliwiajaca wykonywanie inputu w pętli, nie można używać kilku przycisków naraz kosztem przejrzystosci i intuicyjnosci

byte inputDelay = 0;

// Zmienne pamiętające indeks danego submenu

int poziom1 = -1;
int poziom2 = -1;

// Zmienne indeksujące

int menuRozmiar;
int menuIndeks;
int menuPozycja;
int indeks;

// Zmienna wyłącznika urządzenia

bool wylacznik;


// FUNKCJE
// Zwracaniie pozycji w menu

int pozycja(int stanObecny, int indeks, int rozmiar){
  
  if (digitalRead(PRAWO) == HIGH){
    inputDelay = PRAWO; 
    if (stanObecny >= indeks + rozmiar - 1){
      return indeks;
    }
    else{
      stanObecny++;
      return stanObecny;
    }
  }
  if (digitalRead(LEWO) == HIGH){
    inputDelay = LEWO;
    if (stanObecny <= indeks){
       return indeks + rozmiar - 1;
    }
    else{
       stanObecny--;
       return stanObecny;
    }
  }
  return(stanObecny);
}

// Zwracanie czy została naciśnięta opcja nawigacji w menu, cyfry oznaczają wykonywaną funkcję

int menuNawigacja(){
  
  if (digitalRead(OK) == HIGH){
      inputDelay = OK; 
      return 1;
  }
    
  if (digitalRead(ANULUJ) == HIGH){
    inputDelay = ANULUJ;
    if (poziom1 == -1){  
      return 0;
    }else if (poziom2 == -1){
      indeks = poziom1;
      poziom1 = -1;
      return 2;
    }
    else
    {
      indeks = poziom2;
      poziom2 = -1;
      return 2;
    }
  }
  return 0;
}

// Funkcja wykonywana dla komendy która ma być wywołaniem i aktualizacją submenu

void nawigacjaSubmenu(int temp){
   menuIndeks = indeksy[temp];
   menuRozmiar = rozmiary[temp];
   menuPozycja = menuIndeks;
   if (poziom1 == -1){
     poziom1 = indeks;  
   }else if (poziom2 == -1){
     poziom2 = indeks;
 }
    indeks = temp;
}

// Opcja printująca pozycje menu zapisane w pamięci PROGMEM

char buffer[22];

char* printStringow(byte id){
  strcpy_P(buffer, (char *)pgm_read_word(&(listaMenu[id])));
  return buffer;
}

char* printNazwyMenu(byte id){
  strcpy_P(buffer, (char *)pgm_read_word(&(listaSubmenu[id])));
  return buffer;
}

// Skrypt aktywujący dane polecenie zgodnie z listą

void aktywacjaSkryptu(int id){
  switch(id){
    case 0:
      while (digitalRead(ANULUJ) == LOW){
        rysunek(0);
      }
      while (digitalRead(ANULUJ) == HIGH){}
      delay(50);
      break;        
    case 1:
      nawigacjaSubmenu(1);
      break;      
    case 2:
      while (digitalRead(OK) == HIGH){
        rysunek(1);
      }
      wylacznik = false;
      while (digitalRead(ANULUJ) == LOW){
        rysunek(1);
        if (digitalRead(OK) == HIGH){
          break;
        }
      }
      if (wylacznik == true and digitalRead(OK) == HIGH){
        wylaczanie();
      }
      while (digitalRead(ANULUJ) == HIGH or digitalRead(OK) == HIGH){}
      break;  
    case 3:
      nawigacjaSubmenu(2);
      break;      
    case 4:
      nawigacjaSubmenu(3);
      break;      
    case 5:
      nawigacjaSubmenu(4);
      break;      
    case 6:
      nawigacjaSubmenu(5);
      break;
    case 7:
      nawigacjaSubmenu(6);
      break;
    case 8:
       while (digitalRead(ANULUJ) == LOW){
         pomiar(0);
         u8g2.firstPage();
         do{
          u8g2.drawStr(20, 10, String(VRL).c_str());
          u8g2.drawStr(20, 20, String(PomiarTemp).c_str());
          u8g2.drawStr(75, 20, String(currentTemp).c_str());
          u8g2.drawStr(20, 30, String(napiecieWynikowe).c_str());
          u8g2.drawStr(75, 30, String(napieciePomiarowe).c_str());
          u8g2.drawStr(20, 40, String(RS).c_str());
          u8g2.drawStr(20, 50, String(wynik).c_str());

         } while ( u8g2.nextPage() );
         delay(20);
       }
       break;
    case 9:
       break;
    case 10:
      break;      
    case 11:
      break;
    case 12:
      break;
    case 13:
      break;
    case 14:
      break;
    case 15:
      break;
    case 16:
      break;
    case 17:
      break;
    case 18:
      break;    
    case 19:
      break;
    case 20:
      break;      
    case 21:
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
  }
}

// FUNKCJE POMIAROWE

// Funkcja pomiaru napięcia baterii dla pomiaru czujnika oraz wydajności samej baterii

int pomiarNapieciaBaterii(){
  return analogRead(A2);
}

// Funkcja pomiaru temperatury
int16_t temperatura(int x ,byte start){
    OneWire ds(x);
    byte i;
    byte data[2];
    int16_t result;
    do{
        ds.reset();
        ds.write(0xCC);
        ds.write(0xBE);
        for (int i = 0; i < 2; i++) data[i] = ds.read();
        result=(data[1]<<8) |data[0];
        result >>= 4; if (data[1]&128) result |=61440;
        if (data[0]&8) ++result;
        ds.reset();
        ds.write(0xCC);
        ds.write(0x44, 1);
        if (start) delay(1000);
    } while (start--);
    delay(20);
    return result;
}

// Funkcja pomiaru charakterystyk dla gnijącego mięsa

float pomiar(int idPomiaru) {
  currentTemp = temperatura(10,0);
  PomiarTemp = ((0.001*pow(currentTemp, 2))/0.7 * (-((0.006*currentTemp)+0.1))+1.1);
  VRL = 0;
    for (int temp = 0; temp < 10; temp++){
      VRL += (analogRead(A0) / 1024.0) * 5.0;
      delay(1);
    }
  VRL = VRL / 10.0;
  RS = ((5.00-VRL)/VRL) * RL;
  
  napiecieWynikowe = pomiarNapieciaBaterii()/1024.0*5.0;
  napieciePomiarowe = pow((napiecieWynikowe - 2.95), 0.6);
  
  switch (idPomiaru){
    case 0:
      wynik = (pow((RS/Ro), -0.82) - 0.65) * PomiarTemp * napieciePomiarowe;
      break;
    case 1:
      break;
  }
  return wynik;
}

// Funkcja pomiaru baterii i sprawdzająca czy bateria jest za słaba

void pomiarB(){
  if (digitalRead(BATERIA) == HIGH){
    if (bateriaDelay == 5){
      switch (stanBaterii){
        case 5:
          pomiarBaterii = (pomiarNapieciaBaterii() - 760) / 11;
          if (stanTemp < pomiarBaterii){
             stanTemp = pomiarBaterii;
          }
          bateriaDelay = 0;
          stanBaterii = stanTemp;
          break;
        default:
          stanBaterii++;
          bateriaDelay = 0;
          break;
      }
    } else{
      bateriaDelay++;
    }
  } else{
    stanTemp = 0;
    pomiarBaterii = (pomiarNapieciaBaterii() - 745) / 11;
    if (pomiarBaterii < stanBaterii){
      stanBaterii = pomiarBaterii;
    }
    if (stanBaterii < 0){
    wylaczanie();
    }
  }
  return;
  
}


// RYSOWANIE

// Rysowanie wstepnych logotypow przy bootowaniu

void rysunekWstep(int wybor){
  u8g2.firstPage();
  do {
    switch (wybor){
      case 0:
        u8g2.drawXBMP(34, 2, logo60,  logo60, NOTlogo);
        break;

      case 1:
        u8g2.drawXBMP(29, 8, exW, exH, exLogo);
        break;

      case 2:
        u8g2.drawXBMP(34, 2, logo60, logo60, ElektronikLogo);
        break;

      case 3:
        u8g2.drawXBMP(36, 4, OPDProz, OPDProz, OPDP);
        break;
        
      case 4:
          u8g2.drawXBMP(36, 2, meatCheckW, meatCheckH, meatCheckLogo);
          u8g2.drawStr(30,62,"MeatChech+");
          break;
    }
  } while ( u8g2.nextPage() );
}

// Rysowanie oczekiwania na rozgrzanie czujnika i przygotowanie do pomiarów

#define RSwstep 90

void przygotowanie(){
  int temp = (pomiar(0)*100);
  int przyg = (pomiar(0)*100);
  int progressbartemp = 0;
  while (true){
    int progressbar = map((RSwstep-przyg), RSwstep-temp, 0, 1, 100);
    if (progressbartemp < progressbar){
      progressbartemp = progressbar;
    }
    if (przyg > temp){
      temp = przyg;
    }
    u8g2.firstPage();
    do {
      u8g2.drawFrame(14,32,100,10);
      u8g2.drawBox(14,32,progressbartemp, 10);
      u8g2.drawButtonUTF8(63, 20, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "Trwa przygotowanie" );
      
    } while( u8g2.nextPage() );
  if (przyg < RSwstep){
    break;
  }
  przyg = pomiar(0)*100;
  }
  return;
}

// Rysunek menu

void rysunekMenu() {
   pomiarB();
   u8g2.firstPage();
      do {
        u8g2.setDrawColor(1); 
        u8g2.drawXBMP(113, 1, bateriaW, bateriaH, bateria);
        u8g2.drawLine(0, 10, 128, 10);
        for (int temp = 0; temp < stanBaterii; temp++){
          u8g2.drawLine((116 + temp*2), 3, (116 + temp*2), 4); 
        }
        u8g2.drawButtonUTF8(63, 45, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, printStringow(menuPozycja));
        u8g2.drawButtonUTF8(63, 28, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, printNazwyMenu(indeks));
        if (indeks != 0){
          u8g2.drawXBMP(0, 57, navIkonaW, navIkonaH, navPowrot);
        }
        u8g2.drawXBMP(118, 57, navIkonaW, navIkonaH, navOK);
        int kropkiMenu = 63 - (menuRozmiar - 1) * 3;
        int pozycjaMenu = menuPozycja - menuIndeks;
        for (int temp = 0; temp < menuRozmiar; temp++){
          u8g2.drawDisc(kropkiMenu,60,1, U8G2_DRAW_ALL );
          if (pozycjaMenu == temp){
            u8g2.drawDisc(kropkiMenu,60,2, U8G2_DRAW_ALL );
           }
          kropkiMenu = kropkiMenu + 6;
        }
    } while( u8g2.nextPage() );
}

// Logika dla pomiarów nie na żywo DO IMPLEMENTACJI

int skryptPomiaru(){
  
}

// Stringi do rysunku pomiaru

String tekstPomiaru(float dane, float minV, float maxV){
  float rozmiar = maxV - minV;
  int testPomiarowy = (dane - minV) / rozmiar * 2.5 - 0.2;
  switch (testPomiarowy){
    case 0:
      return "Produkt świeży";
    
    case 1:
      return "Produkt nieświeży";

    case 2:
      return "Produkt zepsuty";
  }
}

// Rysowanie miernika lub innych funkcji menu

void rysunek(byte rysID) {
      switch (rysID){
        case 0:
          v = pomiar(0);
          minVal = 0.65;
          maxVal = 3.4;
          if (v < minVal){
             v = minVal;
          }  
          if (v > maxVal){
             v = maxVal;
          }
          punkt = ((v-minVal) * 3.144 / (maxVal-minVal) - 1.572);
          xp = 63+(sin(punkt) * 15);
          yp = 63-(cos(punkt) * 15);
          break;

        case 1:
          if (digitalRead(PRAWO) == HIGH or digitalRead(LEWO) == HIGH){
            wylacznik = !wylacznik;
            while (digitalRead(PRAWO) == HIGH or digitalRead(LEWO) == HIGH){}
            delay(30);
          }
          break;
      }

      pomiarB();
      
      u8g2.firstPage();
      do { 
        u8g2.setDrawColor(1);
        u8g2.drawXBMP(113, 1, bateriaW, bateriaH, bateria);
        u8g2.drawLine(0, 10, 128, 10);
        for (int temp = 0; temp < stanBaterii ; temp++){
          u8g2.drawLine(116 + temp*2, 3, 116 + temp*2, 4); 
        }
        u8g2.drawXBMP(0, 57, navIkonaW, navIkonaH, navPowrot);
        switch (rysID){
          case 0:
            u8g2.drawDisc(63,63,23, U8G2_DRAW_UPPER_LEFT|U8G2_DRAW_UPPER_RIGHT );
            u8g2.setDrawColor(0);
            u8g2.drawDisc(63,63,21, U8G2_DRAW_UPPER_LEFT|U8G2_DRAW_UPPER_RIGHT );
            u8g2.setDrawColor(1);
            u8g2.drawLine(63,63,xp,yp);
            u8g2.drawXBMP(25, 52, ikona12, ikona12, mieso);
            u8g2.drawXBMP(89, 52, ikona12, ikona12, mucha);
            u8g2.drawButtonUTF8(64, 23, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "Stan świeżości:" );
            u8g2.drawButtonUTF8(64, 36, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, tekstPomiaru(v, minVal, maxVal).c_str() );
            break;
          
          case 1:
            u8g2.drawButtonUTF8(64, 22, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "Czy na pewno" );
            u8g2.drawButtonUTF8(64, 34, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "chcesz wyłączyć" );
            u8g2.drawButtonUTF8(64, 46, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "urządznie?" );
            u8g2.drawButtonUTF8(38, 61, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "Nie" );
            u8g2.drawButtonUTF8(88, 61, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "Tak" );
            u8g2.drawFrame(23 + wylacznik*49, 51, 29 + wylacznik*2, 13);
            u8g2.drawXBMP(118, 57, navIkonaW, navIkonaH, navOK);
            break;

          case 2:
            break;
        }

        
      } while( u8g2.nextPage() );  
}

// Funkcja wyłączająca urządzenie

void wylaczanie(){
  while (true){
     u8g2.firstPage();
      do { 
         u8g2.drawButtonUTF8(63, 46, U8G2_BTN_HCENTER|U8G2_BTN_BW0, 0,  1,  1, "Do implementacji" );
      } while( u8g2.nextPage() );  
  }
}

void setup() {
  pomiarB();
  u8g2.begin();
  u8g2.setDrawColor(1);
  u8g2.setFont(u8g2_font_bitcasual_t_all);
  temperatura(10,1);
  for (byte i = 0; i < 5; i++){
    rysunekWstep(i);
    delay(500 + (int(i/4) *1000));
  }
  if (int(pomiar(0)*100) >= RSwstep){    
    przygotowanie();
  }
   menuPozycja = 0;
   menuIndeks = indeksy[0];
   menuRozmiar = rozmiary[0];
}

void loop() {
  if (inputDelay != 0){
    if (digitalRead(inputDelay) == LOW){
      inputDelay = 0;
      delay(10);
    }
  } else{
     menuPozycja = pozycja(menuPozycja, menuIndeks, menuRozmiar);
     int j = menuNawigacja();
    if (j == 1){
      aktywacjaSkryptu(menuPozycja);
    } else if (j == 2){
      menuIndeks = indeksy[indeks];
      menuRozmiar = rozmiary[indeks];
      menuPozycja = menuIndeks;   
    }
  }
  rysunekMenu();
}
